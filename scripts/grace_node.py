#!/home/alex/catkin_ws/src/Grace/yolovenv/bin/python


from typing import Dict, Final, List, Union

import rospy
from grace.msg import RobotGoalMsg, RobotState

# Note: from slam_controller import SlamController is locally imported below


class RobotGoal:
    """A RobotGoal consists of a `parent_object` and a `child_object`. The `parent_object` is the destination to place the `child_object`.

    An example is with a coffee cup and a table, the `parent_object` would be the table and the `child_object` is the coffee cup.
    """

    classes: List[str]= ["person","bicycle","car","motorcycle","airplane","bus","train",
                         "truck","boat","traffic light","fire hydrant","stop sign",
                         "parking meter","bench","bird","cat","dog","horse","sheep",
                         "cow","elephant","bear","zebra","giraffe","backpack","umbrella",
                         "handbag","tie","suitcase","frisbee","skis","snowboard","sports ball",
                         "kite","baseball bat","baseball glove","skateboard","surfboard","tennis racket",
                         "bottle","wine glass","cup","fork","knife","spoon","bowl","banana",
                         "apple","sandwich","orange","broccoli","carrot","hot dog","pizza",
                         "donut","cake","chair","couch","potted plant","bed","dining table",
                         "toilet","tvmonitor","laptop","mouse","remote","keyboard","cell phone",
                         "microwave","oven","toaster","sink","refrigerator","book","clock",
                         "vase","scissors","teddy bear","hair drier","toothbrush"]  # fmt: skip

    def __init__(self, parent_object: str, child_object: str) -> None:
        """
        Args:
            parent_object (str): The object to place the `child_object` on. Must be a valid YOLO class.
            child_object (str): The object to place on a `parent_object`. Must be a valid YOLO class.
        """
        self.parent_object = parent_object
        self.child_object = child_object

    @property
    def parent_object(self) -> str:
        """The object to place the `child_object` on. The table in a coffee cup/table relationship.

        Returns:
            str: The parent object's class name.
        """
        return self._parent_object

    @property
    def child_object(self) -> str:
        """The object to place on a `parent_object`. The coffee cup in a coffee cup/table relationship.

        Returns:
            str: The child object's class name.
        """
        return self._child_object

    @parent_object.setter
    def parent_object(self, new_parent_object: str) -> None:
        if not RobotGoal.is_valid_class(new_parent_object):
            raise ValueError(
                f"Invalid parent object. {new_parent_object} is not in RobotGoal.classes!"
            )
        self._parent_object = new_parent_object

    @child_object.setter
    def child_object(self, new_child_object: str) -> None:
        if not RobotGoal.is_valid_class(new_child_object):
            raise ValueError(
                f"Invalid child object. {new_child_object} is not in RobotGoal.classes!"
            )
        self._child_object = new_child_object

    @staticmethod
    def is_valid_class(_cls: str) -> bool:
        return _cls in RobotGoal.classes

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, RobotGoal):
            return False
        return (
            self.child_object == other.child_object
            and self.parent_object == other.parent_object
        )

    def __str__(self) -> str:
        return f"Goal: Place {self.child_object} on a {self.parent_object}"

    def __repr__(self) -> str:
        return f"RobotGoal(parent_object={self.parent_object}, child_object={self.child_object})"


_states: Dict[int, str] = {
    value: key
    for key, value in RobotState.__dict__.items()
    if not key.startswith("_") and not callable(value) and isinstance(value, int)
}
"""The enum value and their corresponding states from msg/RobotState.msg. Follows key/value of int: STATE.

The keys and values are accessed by getting all the non-callable int constants from the autogenerated python file. 
"""


def state_to_str(state: int) -> str:
    """Returns a string that is human-readable for a state int.

    Args:
        state (int): The state to turn human-readable.

    Returns:
        str: The state in a human-readable form.

    Example:
        >>> state_to_str(0)
        WAITING (0)
        >>> state_to_str(RobotState.WAITING)
        WAITING (0)
    """
    return f"{_states.get(state)} ({state})"


class GraceNode:
    """The main node for controlling the turtlebot. Is the link between a (as of January 23, 2025) theoretical frontend and the turtlebot. Send a goal to /grace/goal to kickstart the application.

    Attributes:
        state (int): The state of the turtlebot. Must be a valid constant in `RobotState.msg`.
        goal (RobotGoal | None): The goal of the robot. Can be None.
        verbose (bool, optional): Whether verbose output should be logged. Defaults to False.
        STATE_TOPIC (str, Final): The topic to publish the states to.
        GOAL_TOPIC (str, Final): The topic to publish the goals to.

    Publishers:
        state_publisher (RobotState): Publishes to STATE_TOPIC. Details the current state of GRACE.
        goal_publisher (RobotGoal): Publishes to GOAL_TOPIC. Contains GRACE's parent and child object.

    Subscribers:
        state_subscriber (RobotState): Subscribes to STATE_TOPIC. Used to keep `state` updated.
    """

    verbose = False
    STATE_TOPIC: Final[str] = "/grace/state"
    GOAL_TOPIC: Final[str] = "/grace/goal"

    def __init__(self, verbose: bool = False) -> None:
        """Initializes the GraceNode.

        Args:
            verbose (bool, optional): Whether verbose output should be logged. Defaults to False.
        """
        self._state: int
        self._goal: Union[RobotGoal, None]
        GraceNode.verbose: bool = verbose

        # TODO: Add a user-friendly input to change the goal and display the state.
        self._state = RobotState.WAITING
        self._goal = None

        self.state_publisher = rospy.Publisher(
            name=GraceNode.STATE_TOPIC, data_class=RobotState, queue_size=5
        )

        self.goal_publisher = rospy.Publisher(
            name=GraceNode.GOAL_TOPIC, data_class=RobotGoalMsg, queue_size=5
        )
        self.state_subscriber = rospy.Subscriber(
            GraceNode.STATE_TOPIC, data_class=RobotState, callback=self.state_callback
        )
        # self.goal_subscriber = rospy.Subscriber(
        #     GraceNode.GOAL_TOPIC, data_class=RobotGoalMsg, callback=self.goal_callback
        # )

        self.state = self._state  # Run the guard function in the setter
        self.state_publisher.publish(self.state)

        if GraceNode.verbose:
            rospy.loginfo(
                f"GRACE is currently {state_to_str(self.state)}{f'. {self.goal}.' if self.goal else ' with no current goal.'}"
            )

        # Local import to resolve circular importing
        from slam_controller import SlamController

        self.slam_controller = SlamController(verbose=GraceNode.verbose)

    def __call__(self) -> None:
        self.run()

    def __repr__(self) -> str:
        return f"GraceNode(state='{state_to_str(self.state)})', goal='{self.goal}')"

    def run(self) -> None:
        rospy.spin()

    def state_callback(self, msg: RobotState) -> None:
        _temp_state: int = self.state  # Used for verbose logging
        try:
            self.state = msg.state
            if GraceNode.verbose:
                rospy.loginfo(
                    f"Changed state from {state_to_str(_temp_state)} to {state_to_str(msg.state)}."
                )
        except ValueError as ve:
            rospy.logerr(f"Error while changing state: {ve}")

    def publish_goal(self) -> None:
        """Publishes GraceNode's current goal using `goal_publisher`. If `goal` is None, it will log an error and do nothing.

        Usage:
            >>> grace.goal = RobotGoal(parent_object="dining table", child_object="cup") # Set the goal
            >>> grace.publish_goal() # Publish the goal
        """
        if self.goal is None:
            rospy.logerr("Attempted to publish an empty goal in GraceNode. Ignoring...")
            return

        self.goal_publisher.publish(
            self.goal.parent_object,
            self.goal.child_object,
        )
        if GraceNode.verbose:
            rospy.loginfo(f"Successfully published goal! {self.goal}.")

    @property
    def state(self) -> int:
        """The state of the turtlebot. The default state is `RobotState.WAITING`.

        Returns:
            int: A value within msg/RobotState.msg's constants.
        """
        return self._state

    @state.setter
    def state(self, new_state: int) -> None:
        if new_state not in _states.keys():
            raise ValueError(
                f"Invalid state {new_state}. It is not a defined state in RobotState.msg"
            )
        self._state = new_state

    @property
    def goal(self) -> Union[RobotGoal, None]:
        """The goal of the turtlebot. Contains a parent_object and a child_object. See `RobotGoal`'s documentation for details.

        Returns:
            RobotGoal: The turtlebot's goal.

        Usage:
            >>> grace.goal = RobotGoal(parent_object="dining table", child_object="cup") # Set the goal
            >>> grace.publish_goal() # Publish the goal
        """
        return self._goal

    @goal.setter
    def goal(self, new_goal: RobotGoal) -> None:
        _temp_goal: Union[RobotGoal, None] = self.goal
        self._goal = new_goal  # new_goal will be validated within RobotGoal's setters
        if GraceNode.verbose:
            rospy.loginfo(f"Changed goal from {_temp_goal} to {self._goal}.")
        self.goal_callback(self._goal)

    def goal_callback(self, goal: RobotGoal) -> None:
        # BUG: This is blocking the publish_goal
        result: bool = self.slam_controller.explore(goal, timeout=60 * 20)
        if result:
            rospy.loginfo("Reached goal!")

    def shutdown(self) -> None:
        """The callback for when the GraceNode needs to be shutdown through a ROSInterruptExecption."""
        # Currently does nothing, but is here for possible future use.
        if GraceNode.verbose:
            rospy.loginfo("Shutting down GraceNode!")


if __name__ == "__main__":
    rospy.init_node(name="GraceNode")  # type: ignore
    grace = GraceNode(verbose=True)
    rospy.on_shutdown(grace.shutdown)
    grace.goal = RobotGoal(parent_object="dining table", child_object="cup")
    grace.publish_goal()
    try:
        grace.run()
    except rospy.ROSInterruptException:
        grace.shutdown()
        rospy.loginfo("GraceNode terminated GRACEfully.")  # type: ignore
